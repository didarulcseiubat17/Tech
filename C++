GG-------------
(A method has parameters and takes arguments. argument is the value/variable/reference being passed in, parameter is the receiving variable used w/in the function/block.) 

References in C++/////////////
When a variable is declared as reference, it becomes an alternative name for an existing variable. A variable can be declared as reference by putting ‘&’ in the declaration.(ampersand)
int& ref = x;

References vs Pointers//////////
Both references and pointers can be used to change local variables of one function inside another function. Both of them can also be used to save copying of big objects when passed as arguments to functions or returned from functions, to get efficiency gain.
References are less powerful than pointers
1) Once a reference is created, it cannot be later made to reference another object; it cannot be reseated. This is often done with pointers.
2) References cannot be NULL. Pointers are often made NULL to indicate that they are not pointing to any valid thing.
3) A reference must be initialized when declared. There is no such restriction with pointers
References are safer and easier to use:
1) Safer: Since references must be initialized, wild references like wild pointers are unlikely to exist. It is still possible to have references that don’t refer to a valid location 
2) Easier to use: References don’t need dereferencing operator to access the value. They can be used like normal variables. ‘&’ operator is needed only at the time of declaration. Also, members of an object reference can be accessed with dot operator (‘.’), unlike pointers where arrow operator (->) is needed to access members.
**Together with the above reasons, there are few places like copy constructor argument where pointer cannot be used. Reference must be used pass the argument in copy constructor. Similarly references must be used for overloading some operators like ++.
In C++, Reference variables are safer than pointers because reference variables must be initialized and they cannot be changed to refer to something else once they are initialized. But there are exceptions where we can have invalid references.
1) Reference to value at uninitialized pointer.
int *ptr;
int &ref = *ptr;  // Reference to value at some random memory location
2) Reference to a local variable is returned.
int& fun()
{
   int a = 10;
   return a;
}
Once fun() returns, the space allocated to it on stack frame will be taken back. So the reference to a local variable will not be valid.

Pass arguments by reference or pointer://///////////
1) To modify local variables of the caller function: A reference (or pointer) allows called function to modify a local variable of the caller function. 
2) For passing large sized arguments: If an argument is large, passing by reference (or pointer) is more efficient because only an address is really passed, not the entire object. 
3) To avoid Object Slicing: If we pass an object of subclass to a function that expects an object of superclass then the passed object is sliced if it is pass by value. 
4) To achieve Run Time Polymorphism in a function 
We can make a function polymorphic by passing objects as reference (or pointer) to it.

Function Overloading in C++///////////////
Function overloading is a feature in C++ where two or more functions can have the same name but different parameters.
Function overloading can be considered as an example of polymorphism feature in C++.

Functions that cannot be overloaded in C++(error)///////
1) Function declarations that differ only in the return type. 
2) Member function declarations with the same name and the name parameter-type-list cannot be overloaded if any of them is a static member function declaration. 
3) Parameter declarations that differ only in a pointer * versus an array [] are equivalent. 
4) Parameter decla'rations that differ only in that one is a function type and the other is a pointer to the same function type are equivalent.
5) Parameter declarations that differ only in the presence or absence of const and/or volatile are equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called. 
6) Two parameter declarations that differ only in their default arguments are equivalent. 

Function overloading and const keyword
C++ allows member methods to be overloaded on the basis of const type. Overloading on the basis of const type can be useful when a function return reference or pointer. We can make one function const, that returns a const reference or const pointer, other non-const function, that returns non-const reference or pointer.
C++ allows functions to be overloaded on the basis of const-ness of parameters only if the const parameter is a reference or a pointer. 

Overloading doesn’t work for derived class in C++ programming language. There is no overload resolution between Base and Derived. 

To overload main() function in C++, it is necessary to use class and declare the main as member function. Note that main is not reserved word in programming languages like C, C++, Java and C#. 

Inline Functions in C++////////////////
For small, commonly-used functions, the time needed to make the function call is often a lot more than the time needed to actually execute the function’s code. 
In fact, all the functions defined inside the class are implicitly inline. If you need to explicitly declare inline function in the class then just declare the function inside the class and define it outside the class using inline keyword.

OOP=================
Object: Objects are basic run-time entities in an object oriented system, objects are instances of a class these are defined user defined data types. Object take up space in memory and have an associated address。
Class: Class is a blueprint of data and functions or methods. Class does not take any space.
Encapsulation: Wrapping up(combing) of data and functions into a single unit is known as encapsulation. The data is not accessible to the outside world and only those functions which are wrapping in the class can access it. This insulation of the data from direct access by the program is called data hiding or information hiding.
Data abstraction refers to, providing only needed information to the outside world and hiding implementation details. 
Inheritance: inheritance is the process by which objects of one class acquire the properties of objects of another class.
Polymorphism: polymorphism means ability to take more than one form. An operation may exhibit different behaviors in different instances. The behavior depends upon the types of data used in the operation.
C++ supports operator overloading and function overloading.
Operator overloading is the process of making an operator to exhibit different behaviors in different instances is known as operator overloading.
Function overloading is using a single function name to perform different types of tasks.
Dynamic Binding: In dynamic binding, the code to be executed in response to function call is decided at runtime. C++ has virtual functions to support this.
Message Passing: Objects communicate with one another by sending and receiving information to each other. 

A class declaration can contain static object of self type, it can also have pointer to self type, but it cannot have a non-static object of self type.
class Test {
  static Test self;  // works fine
};//Static variables do not contribute to the size of objects. So no problem in calculating size with static variables of self type.
For a com'piler, all pointers have a fixed size irrespective of the data type they are pointing to, so no problem with this also.
Size of an empty class is not zero. It is 1 byte generally. It is nonzero to ensure that the two different objects will have different addresses.

static member functions in C++////////
1) static member functions do not have this pointer.
2) A static member function cannot be virtual
3) Member function declarations with the same name and the name parameter-type-list cannot be overloaded if any of them is a static member function declaration.
4) A static member function can not be declared const, volatile, or const volatile.

The keyword static can be used in three major contexts: inside a function, inside a class definition, and in front of a global variable inside a file making up a multifile program.
1.1 The use of static inside a function is the simplest. It simply means that once the variable has been initialized, it remains in memory until the end of the program. You can think of it as saying that the variable sticks around, maintaining its value, until the program completely ends. 
1.2 You can also use static in this fashion to prevent a variable from being reinitialized inside a loop. The trick is that the keyword static prevents re-initialization of the variable. One feature of using a static keyword is that it happens to be initialized to zero automatically for you -- but don't rely on this behavior
1.3 You might use a static variable in order to preserve information about the last value a function returned, 
2.1 The second use of static is inside a class definition. While most variables declared inside a class occur on an instance-by-instance basis, a static member variable has the same value in any instance of the class and doesn't even require an instance of the class to exist. Importantly, it is good syntax to refer to static member functions through the use of a class name (class_name::x; rather than instance_of_class.x;). Doing so helps to remind the programmer that static member variables do not belong to a single instance of the class and that you don't need to have a single instance of a class to use a static member variable. As you have probably noticed, to access the static member, you use the scope operator, ::, when you refer to it through the name of the class.
   you cannot initialize the static class member inside of the class.
2.2 Static member functions are functions that do not require an instance of the class, static member functions can only operate on static members, Static member functions can be used to modify static member variables to keep track of their values
Notice that you must include the type of the static variable when you set it!
3. The last use of static is as a global variable inside a file of code. It's scope -- or visibility -- is limited to the file.











PQ---------
Any C++ class with at least one pure virtual function is considered to be an abstract class. This means that there can be no object created for that class (since it is abstract). abstract classes in C++ are not explicitly declared to be abstract – having a pure virtual function implicitly makes a class abstract in C++. 
A pure virtual function is a function that has the notation "= 0" in the declaration of that function. 
Base class constructors and derived class destructors are called first
